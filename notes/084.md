# Largest Rectangle in Histogram


## 题目

   给一个数组,每个数组的值表示一个高度，如 {2,1,5,6,2,3} 表示6个底为1高分别为2,1,5,6,2,3的矩形。找出矩阵之间组合而成的最大的矩形。这里是10(5和6)
   之间组合。

## 思路


## 代码

```cpp

class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> index;
        //使整个循环更简洁
        heights.push_back(0);
        int n = heights.size();
        int res = 0;
        for( int i=0 ; i < n ; ++i ){
            //stack不为空的时候且当前i表示的矩形大小小于前一个矩形
            while(!index.empty() && heights[index.top()]>=heights[i]){
                int h = heights[index.top()];
                index.pop();
                //等于-1表示从第一个矩形开始到当前h表示的矩形都要穿进去
                //等于index.top()表示从比他小的一个矩型开始到当前h表示的矩形
                int left = index.empty() ? -1 : index.top() ;
                int wide = i - left -1;
                if(h*wide>res) res = h*wide;
            }
            index.push(i);
        }    
        return res;
    }
};

```


下面代码是一个动态规划的思路，算法是正确的，但在leetcode无法通过。卡在倒数第二个例子。

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int heights_sz = heights.size();
        if(heights_sz==0) 
            return 0;
        if(heights_sz==1) 
            return heights[0];
         //0行0列不用
        vector<int> e(heights_sz+1,0);  
        vector<int> min_value(heights_sz+1);
        
        //初始化
        for(int i=1;i<=heights_sz;++i){
            e[i] = heights[i-1];
            min_value[i] = heights[i-1];
        }
        
        for(int l=2;l<=heights_sz;++l){
            for(int i=1;i<=heights_sz-l+1;++i){
                int j=i+l-1;
                min_value[i] = min(min_value[i],min_value[i+1]);
                int temp = max(e[i],e[i+1]);
                e[i] = max(temp,(j-i+1)*min_value[i]);
            }
        } 
        return e[1];
    }
};

```
